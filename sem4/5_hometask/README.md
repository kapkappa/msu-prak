1. Опишите абстрактный класс  FloatPair, представляющий пару чисел типа float и имеющий чисто виртуальную функцию для вычисления некоторой меры:
    *virtual float Measure() const;*

2. Унаследуйте от FloatPair класс Segment, задающий понятие отрезка числовой прямой (то есть числа, заданные базовым классом, рассматриваются как начальная и конечная точки отрезка; своих полей-данных класс Segment иметь не должен). При попытке сконструировать отрезок, начальная точка которого правее конечной, выбрасывайте исключение типа BadSegment (класс можно оставить пустым). Функцию Measure() определите как длину отрезка.

3.  Введите в классе операцию сложения, которая по двум отрезкам, полностью или частично перекрывающимся, строит новый отрезок, содержащий все точки исходных отрезков (объединение). Если отрезки не имеют общих точек, их объединение не будет отрезком; в этом случае выбрасывайте исключение класса BadAddition, в объекте которого должны содержаться границы обоих отрезков, которые не удалось сложить.

В результате следующая функция main(): 

```cpp
int main() {
    try { 
        Segment f(1,2), g(0.5, 5), h(2.5, 6.5);
        printf("%3.3f, %3.3f, %3.3f\n", (f+g).Measure(), (g+h).Measure(), (f+g+h).Measure());
        printf("%3.3f \n", (f+h).Measure()); 
    }
    catch (const BadAddition &bad) { printf("Bad addition: [%3.3f; %3.3f] + [%3.3f; %3.3f]\n", 
           bad.GetA1(), bad.GetB1(), bad.GetA2(), bad.GetB2()); }
    catch (BadSegment b) { printf("Bad segment\n"); }
    return 0; 
}
```

должна откомпилироваться без ошибок и предупреждений, отработать и выдать

    *4.500, 6.000, 6.000 BadAddition: [1.000; 2.000]+[2.500; 6.500]*

[x] Все поля должны быть в закрытой (private) части базового класса, открытыми и защищёнными могут быть только функции-члены.
[x] Использование директивы friend запрещено.
[x] Для инициализации объектов используются конструкторы.
[x] Никакие методы не должны изменять внутренние поля объектов, допускаются только функции, возвращающие значения полей (но не меняющие ничего).
